<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Forms in iOS native apps</title>
    <link rel="shortcut icon" href="favicon.ico">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/intopia.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'dist/theme/pdf.css' : 'dist/theme/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <div class="menu">
          <a href="index.html#session01">Home<span class="hidden"> - list of all slide decks</span></a> | <a href="#/">Start<span class="hidden"> of slide deck</span></a>
        </div>
 
        <section data-background="#EDEBEB">
          <img class="intopia-logo" src="assets/img/logo-intopia.png" alt="Intopia">
          <h1>Forms in iOS native apps</h1>
        </section>



<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->



        <section id="slide-what-will-we-cover">
          <section data-background="#EDEBEB">
            <h3>What will we cover?</h3>
          </section>

          <section data-background="#EDEBEB">
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span><a href="#slide-two-modes">Part 1. Screen reader modes on the web</a></li>
              <li><span aria-hidden="true" class="icon icon-check"></span><a href="#slide-mobile">Part 2. Why mobile feels different</a></li>
            </ul>

            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span><a href="#slide-changing-your-mental-model">Part 3. Web vs iOS: shifting your mental model</a></li>
              <li><span aria-hidden="true" class="icon icon-check"></span><a href="#slide-swiftUI-structure">Part 4. SwiftUI language basics</a></li>
            </ul>

            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span><a href="#slide-adding-accessible-names">Part 5. Adding accessible names</a></li>
              <li><span aria-hidden="true" class="icon icon-check"></span><a href="#slide-adding-instructions-errors">Part 6. Adding instructions and error messages</a></li>
            </ul>
          </section>
        </section>



<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->



        <section id="slide-two-modes">
          <section data-background="#EDEBEB">
            <h3>Part 1. Screen reader modes on the web</h3>
          </section>

          <section data-background="#EDEBEB">
            <p>On desktop web, screen readers like NVDA and JAWS <b>operate in two modes</b>:</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>Browse mode</h5>
            <p>Lets users read through the whole page, line by line and element by element.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>Forms mode (JAWS)/ Focus mode (NVDA)</h5>
            <p>Triggered when entering form controls, or manually toggled.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>In forms mode, keystrokes are sent <b>directly to the focused control</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Screen readers usually only announce the control itself and any information that is <b>programmatically associated with it</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Anything not programmatically tied to a form control <b>can effectively become invisible</b> while the user is in forms mode.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>This is why programmatic association is <b>non-negotiable</b> on the web-based forms.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Without these connections, <b>users may miss essential information</b>!</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Some <b>common methods</b> include:</p>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">&lt;!-- Labels: matching for and id values --&gt;</span>

&lt;label <span class="codeHighlight">for="aaa"</span>&gt;Email&lt;/label&gt;
&lt;input <span class="codeHighlight">id="aaa"</span> type="text"&gt;</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">&lt;!-- Instructions / errors: aria-describedby --&gt;</span>

&lt;label for="bbb"&gt;Email&lt;/label&gt;
&lt;span <span class="codeHighlight">id="ccc"</span>&gt;Use your full email address&lt;/span&gt;
&lt;input id="bbb" <span class="codeHighlight">aria-describedby="ccc"</span>&gt;</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">&lt;!-- Invalid fields: aria-invalid="true" --&gt;</span>

&lt;label for="fff"&gt;Email&lt;/label&gt;
&lt;input id="fff" <span class="codeHighlight">aria-invalid="true"</span>&gt;</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">&lt;!-- Required fields: aria-required="true"
or required --&gt;</span>

&lt;label for="hhh"&gt;Email&lt;/label&gt;
&lt;input id="hhh" <span class="codeHighlight">required</span>&gt;</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">&lt;!-- Radio group headings: fieldset, legend --&gt;</span>

&lt;fieldset&gt;
  <span class="codeHighlight">&lt;legend&gt;Do you like boats?&lt;/legend&gt;</span>
  ...
&lt;/fieldset&gt;</code></pre>
          </section>
        </section>



<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->



        <section id="slide-mobile">
          <section data-background="#EDEBEB">
            <h3>Part 2. Why mobile feels different</h3>
          </section>

          <section data-background="#EDEBEB">
            <p>Mobile screen readers (VoiceOver, TalkBack) <b>do not have forms mode</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Users can <b>touch any element</b> on the screen to hear it announced.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>They can also swipe through <b>all focusable items</b> on the screen.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>This includes <b>labels, instructions and error messages</b> if those items are exposed to accessibility.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>This means users are likely to encounter text nearby form controls, <b>even if they&rsquo;re  not not formally associated</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>This creates the illusion that <b>“mobile forms don’t really need programmatic association.”</b></p>
          </section>

          <section data-background="#EDEBEB">
            <p>But that illusion is <b>misleading</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Let’s look at some examples to help explain why programmatic association is <b>still essential on mobile</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <h4>Example 1: Touch exploration</h4>
          </section>

          <section data-background="#EDEBEB">
            <p>A screen reader user taps <b>directly on a form field</b> that has a visible label and instructions.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Only <b>programmatically attached information</b> is announced.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>In the worst case, if the <b>label and instructions</b> aren&rsquo;t programmatically associated, they will get:</p>
            <p><em>“Text field.”</em></p>
          </section>

          <section data-background="#EDEBEB">
            <p>If the label is programmatically associated <b>but the instructions are not</b>, they will get:</p>
            <p><em>“Phone number. Text field.”</em></p>
          </section>

          <section data-background="#EDEBEB">
            <p>If the label and instructions <b>are programmatically associated</b>, they will get:</p>
            <p><em>“Phone number. Include your area code. Text field.”</em></p>
          </section>

          <section data-background="#EDEBEB">
            <p>Users could swipe up or down to find out more, <b>but they should not have to</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Touch exploration is incredibly common — and it means that <b>we must prgrammatically associated key info</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <h4>Example 2: Swiping into a field with an error message below it.</h4>
          </section>

          <section data-background="#EDEBEB">
            <p>Imagine an error message positioned after a field <b>but it has not been programmatically associated</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>This time, the screen reader user is <b>swiping through each item</b> on the screen.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>They may <b>hear the following</b>:</p>
            <p>Swipe 1 - Text label: <em>“Email.”</em></p>
            <p>Swipe 2 - Form field: <em>“Text field.”</em></p>
          </section>

          <section data-background="#EDEBEB">
            <p>They may even hear the following <b>if the label has been associated</b>:</p>
            <p>Swipe 1 - Text label: <em>“Email.”</em></p>
            <p>Swipe 2 - Form field: <em>“Email. Text field.”</em></p>
          </section>

          <section data-background="#EDEBEB">
            <p>But they will not be aware that there is an error message <b>directly below the field</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>So, they will not know that the field is <b>currently in a state of error</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>And, they will not have any information that <b>may help them resolve the error</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Ideally, they should hear the following <b>when swiping to the field</b>:</p>
            <p><em>“Email. Error: Must be a valid email address. Text field.”</em></p>
          </section>
        </section>



<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->



        <section id="slide-changing-your-mental-model">
          <section data-background="#EDEBEB">
            <h3>Part 3. Web vs iOS: shifting your mental model</h3>
          </section>

          <section data-background="#EDEBEB">
            <h4>1. No structural hierarchy</h4>
          </section>

          <section data-background="#EDEBEB">
            <p>In HTML, there is a <b>strong hierarchy of information</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Elements combine to form a <b>meaningful, navigable document outline</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>For example:</h5>
            <ul class="icon-list">
              <li><span aria-hidden="true" class="icon icon-check"></span>Headings form a nested tree.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Landmarks define regions of the page.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Lists introduce grouping and order.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Tables provide grid relationships.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p>The DOM <b>provides the structural hierarchy</b>, and the accessibility tree is generated directly from that structure.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>In iOS, there is <b>no inherent hierarchy of information</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>VoiceOver receives a flat list of elements <b>unless you explicitly group them</b> or control their reading order.</p>
          </section>

          <section data-background="#EDEBEB">
            <h4>2. Limited semantics</h4>
          </section>

          <section data-background="#EDEBEB">
            <p>Every HTML element has <b>built-in semantics</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Each element carries a <b>native role and purpose</b> that browsers and assistive technologies understand.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>iOS <b>does not create semantics</b> for layouts and relationships (no headings, no grouping, no document outline).</p>
          </section>

          <section data-background="#EDEBEB">
            <p>However, controls do have <b>built-in semantics</b>:</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>Examples of built-in control semantics:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span><code>TextField</code> – exposes the text field trait automatically</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>Button</code> – has the button trait automatically</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>Toggle</code> – is a switch with on/off state and role</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>SecureField</code> – is automatically a secure text entry</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h4>3. No form structure</h4>
          </section>

          <section data-background="#EDEBEB">
            <p>On the web, HTML provides <b>three levels</b> of form structure:</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>Level 1: Form controls</h5>
            <p>The elements users interact with (input, textarea, select, checkbox, etc.)</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>Level 2: Form fields</h5>
            <p>A combination of:</p>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>The label</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>The control</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Instructions (optional)</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Required indicators (optional)</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Error messages (optional)</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Level 3: Form groups</h5>
            <p class="font-sm">Sets of related fields grouped under a shared heading, announced together by screen readers via <code>&lt;fieldset&gt;</code> and <code>&lt;legend&gt;</code>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>In iOS only the lowest-level concept exists — <b>controls</b> (TextField, Button, Picker, Toggle, etc.).</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>But:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>There is no “form field” concept.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>There is no container that binds label + control + instructions + error.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>There is no <code>&lt;fieldset&gt;</code> or semantic form grouping.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Developers must manually assemble the entire experience:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>A Text view (visible label)</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>A TextField or other control</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>A Text view for instructions or errors</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Optional grouping using accessibility containers</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h4>4. No semantic &lt;label&gt; element</h4>
          </section>

          <section data-background="#EDEBEB">
            <p>In the web world, we have the <code>&lt;label&gt;</code> element, which is used with form fields to <b>provide a programmatically associated label</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>In SwiftUI/iOS, there is no <b>semantic</b> <code>&lt;label&gt;</code> <b>element</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>There is only:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Visual text (<code>Text</code>).</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Interactive controls (<code>TextField</code>, <code>SecureField</code>, etc).</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Unlike the web:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>You cannot bind a visual <code>Text</code> element to a form control.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>There is no equivalent of <code>&lt;label for="id"&gt;</code>.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>iOS does not infer any relationship between a <code>Text</code> and a <code>TextField</code>.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p>This means all accessibility information must be <b>applied directly to the control itself</b>, including:</p>
          </section>

          <section data-background="#EDEBEB">
            <ul class="icon-list">
              <li><span aria-hidden="true" class="icon icon-check"></span>Accessible name</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Required state</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Instructions</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Error messages</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h4>5. No semantic states</h4>
          </section>

          <section data-background="#EDEBEB">
            <p>Another major difference between the web and iOS is how <b>form field states are handled</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>On the web: <b>states are semantic</b>. For example:</p>
          </section>

          <section data-background="#EDEBEB">
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Error state: <code>aria-invalid="true"</code></li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Required state: <code>required</code> or <code>aria-required="true"</code></li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p>These states are semantic, machine-readable, and appear as <b>distinct items in the accessibility tree</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>In iOS/SwiftUI: <b>states are not semantic</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>iOS has <b>no equivalent properties</b> for:</p>
            <ul class="icon-list">
              <li><span aria-hidden="true" class="icon icon-check"></span>“invalid”</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>“required”</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p>There is <b>no built-in way</b> to declare a field as <code>required</code> or <code>invalid</code> using accessibility APIs.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Instead, everything must be <b>expressed through text</b>.</p>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Error messages: “Error: You must use a valid email address.”</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Required fields: “Email, required.”</li>
            </ul>
          </section>
        </section>



<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->



        <section id="slide-swiftUI-structure">
          <section data-background="#EDEBEB">
            <h3>Part 4. SwiftUI language basics</h3>
          </section>

          <section data-background="#EDEBEB">
            <p>Before we look at some form examples, here is <b>a breakdown of SwiftUI structure</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>Why SwiftUI?</h5>
            <p>Because the code is less intimidating that UIKit.</p>
          </section>


          <section data-background="#EDEBEB">
            <h4>Example 1: A heading</h4>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// View: Like an HTML element</span>

<span class="codeHighlight">Text("Testing forms")
  .font(.largeTitle.weight(.bold))
  .accessibilityAddTraits(.isHeader)
  .padding(.bottom, 8)</span></code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// View type: Like an HTML role</span>

<span class="codeHighlight">Text</span>("Testing forms")
  .font(.largeTitle.weight(.bold))
  .accessibilityAddTraits(.isHeader)
  .padding(.bottom, 8)</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Initialiser argument: What the view displays</span>

Text(<span class="codeHighlight">"Testing forms"</span>)
  .font(.largeTitle.weight(.bold))
  .accessibilityAddTraits(.isHeader)
  .padding(.bottom, 8)</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Modifiers: Like CSS + ARIA attributes</span>

Text("Testing forms")
  <span class="codeHighlight">.font(.largeTitle.weight(.bold))
  .accessibilityAddTraits(.isHeader)
  .padding(.bottom, 8)</span></code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Modifier parameters: like CSS property values</span>

Text("Testing forms")
  .font(<span class="codeHighlight">.largeTitle.weight(.bold)</span>)
  .accessibilityAddTraits(<span class="codeHighlight">.isHeader</span>)
  .padding(<span class="codeHighlight">.bottom, 8</span>)</code></pre>
          </section>

          <section data-background="#EDEBEB">
            <h4>Example 2: A <code>TextField</code></h4>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// View: Like a text field element</span>

<span class="codeHighlight">TextField("Phone", text: $phone)</span></code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// View type: Like the role of input</span>

<span class="codeHighlight">TextField</span>("Phone", text: $phone)</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Initialiser arguments: placeholder + binding</span>

TextField(<span class="codeHighlight">"Phone", text: $phone</span>)</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Placeholder text: Shown when the field is empty</span>

TextField(<span class="codeHighlight">"Phone"</span>, text: $phone)</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Binding: Updates the variable as the user types</span>

TextField("Phone", <span class="codeHighlight">text: $phone</span>)</code></pre>
          </section>

          <section data-background="#EDEBEB">
            <h4>The importance of <code>@State</code></h4>
          </section>

          <section data-background="#EDEBEB">
            <p>This “binding” (<code>$phone</code>) <b>connects the control</b> to a <code>@State</code>. For example:</p>
        </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// @State property</span>
@State private var <span class="codeHighlight">phone</span> = ""

<span class="codeComment">// Textfield control</span>
TextField("Phone", text: <span class="codeHighlight">$phone</span>)</code></pre>
          </section>

          <section data-background="#EDEBEB">
            <p><code>@State</code> is how SwiftUI lets the app <b>store information</b> that can change while the user is interacting with the screen.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>This stored information can include:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Text typed by a user.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Whether a toggle is on/off.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Whether a menu is open or closed.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Which tab is selected.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>What page you're on.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p><code>@State</code> is <b>very important</b> from an accessibility perspective.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>On the web, <b>the DOM</b> stores each field’s value.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>When a user types into a form control:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>The DOM input value is updated.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>The accessibility tree value is updated.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Screen readers announce the correct value when focus returns.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p>In SwiftUI, the <code>@State</code> variable stores the field’s value.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>When a user types into a TextField:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>The <code>@State</code> variable is updated.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>SwiftUI re-runs the view and updates only the parts that changed.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>SwiftUI reconstructs accessibility information as part of its view update.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>VoiceOver announces the updated value when focus returns.</li>
            </ul>
          </section>
        </section>



<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->



        <section id="slide-adding-accessible-names">
          <section data-background="#EDEBEB">
            <h3>Part 5. Adding accessible names</h3>
          </section>

          <section data-background="#EDEBEB">
            <p>Let’s start with a <b>visible text label above a form field</b>.</p>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true">
<span class="codeComment">// Visible text label</span>
Text("Phone")
  .font(.headline)

<span class="codeComment">// Form field</span>
TextField("Phone", text: $phone)</code></pre>
          </section>

          <section data-background="#EDEBEB">
            <p>We can add <b>an accessible name</b> to a <code>TextField</code> in two ways.</p>
          </section>

          <section data-background="#EDEBEB">
            <h4>Method 1. Use <code>placeholder</code></h4>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true">
<span class="codeComment">// Visible text label</span>
Text("Phone")
  .font(.headline)

<span class="codeComment">// Form field</span>
TextField(<span class="codeHighlight">"Phone"</span>, text: $phone)</code></pre>
          </section>

          <section data-background="#EDEBEB">
            <p>While the placeholder can be used to create an accessible name, <b>it is not recommended</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Placeholder stops being visible once the user types, which makes behaviour unpredictable.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>VoiceOver sometimes uses placeholder as editing label, which is announced differently when editing vs when entering.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Placeholder is not read in all rotor modes.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h4>Method 2. Use <code>accessibilityLabel</code></h4>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Visible text label</span>
Text("Phone")
  .font(.headline)

<span class="codeComment">// Form field</span>
TextField("", text: $phone)
  <span class="codeHighlight">.accessibilityLabel("Phone")</span></code></pre>
          </section>

          <section data-background="#EDEBEB">
            <p>This method can also be used to <b>add additional information</b> such as “required”.</p>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Visible text label</span>
Text("Phone")
  .font(.headline)

<span class="codeComment">// Form field</span>
TextField("", text: $phone)
  <span class="codeHighlight">.accessibilityLabel("Phone, required")</span></code></pre>
          </section>

          <section data-background="#EDEBEB">
            <p>SwiftUI exposes <b>two separate concepts to VoiceOver</b>:</p>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>The accessible name (from <code>accessibilityLabel</code>)</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>The editing label (derived from the <code>placeholder</code>)</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p>So, the <code>placeholder</code> is still used internally by SwiftUI <b>as the TextField’s editing label</b>, even when you override the accessible name.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>In some cases, the placeholder value and <code>accessibilityLabel</code> value are <b>both announced when the field receives focus</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>The <b>most robust method</b> of appling an accessible name to controls is to use the <code>.accessibilityLabel</code> and with the <code>placeholder</code> set to <code>""</code>.</p>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Visible text label</span>
Text("Phone")
  .font(.headline)

<span class="codeComment">// Form field</span>
TextField(<span class="codeHighlight">""</span>, text: $phone)
  .accessibilityLabel(<span class="codeHighlight">"Phone, required"</span>)</code></pre>
          </section>

          <section data-background="#EDEBEB">
            <h4>Two other advanced methods</h4>
          </section>

          <section data-background="#EDEBEB">
            <p>Two very advanced techniques exist in SwiftUI for <b>creating accessible names and combining content</b> - but they are not recommended:</p>
          </section>

          <section data-background="#EDEBEB">
            <p><code>accessibilityRepresentation { }</code></p>
            <p>Allows you to replace the entire accessibility object with a custom one.</p>
          </section>

          <section data-background="#EDEBEB">
            <p><code>accessibilityElement(children: .ignore)</code></p>
            <p>Tells VoiceOver to ignore everything inside a view and treat the parent as one combined element.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>These techniques give developers <b>total control over what VoiceOver reads</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>They are not <b>recommended or needed</b> for standard form fields.</p>
          </section>
        </section>



<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->



        <section id="slide-adding-instructions-errors">
          <section data-background="#EDEBEB">
            <h3>Part 6. Adding instructions and error messages</h3>
          </section>

          <section data-background="#EDEBEB">
            <p>We’ll look at <b>three approaches</b> to associating instructions and errors with form fields.</p>
          </section>

          <section data-background="#EDEBEB">
            <h4>Method 1: <code>accessibilityLabel</code></h4>
          </section>

          <section data-background="#EDEBEB">
            <p>Sadly, the most robust method is to <b>add instructions or errors</b> directly into the <code>accessibilityLabel</code>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>With this method, you can add the instructions or errors <b>to the accessible name</b>:</p>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Visible text label</span>
Text("Phone")
  .font(.headline)

<span class="codeComment">// Form field</span>
TextField("", text: $phone)
  .accessibilityLabel(<span class="codeHighlight">"Phone, Include your area code"</span>)</code></pre>
          </section>

          <section data-background="#EDEBEB">
            <h5>Pros:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Easy to implement</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Very robust.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Cons:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Can create a long accessible name</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Yes, it’s ugly.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Yes, it’s verbose.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Yes, it feels wrong.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>But it is the only 100% reliable method.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h4>Method 2: <code>accessibilityHint</code></h4>
          </section>

          <section data-background="#EDEBEB">
            <p><code>accessibilityHint</code> allows you to <b>attach a short description</b> to the control.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>It was originally designed for <b>interaction guidance</b>, not form-related instructions or errors.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>Examples of interaction guidance</h5>
            <ul class="icon-list">
              <li><span aria-hidden="true" class="icon icon-check"></span><em>“Swipe left to reveal more items”</em></li>
              <li><span aria-hidden="true" class="icon icon-check"></span><em>“Double tap to enlarge”</em></li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p>But <code>accessibilityHint</code> is often used to <b>attach simple instructions</b>.</p>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Visible text label</span>
Text("Phone")
  .font(.headline)

<span class="codeComment">// Form field</span>
TextField("", text: $phone)
  .accessibilityLabel("Phone, required")
  <span class="codeHighlight">.accessibilityHint("Include your area code")</span></code></pre>
          </section>

          <section data-background="#EDEBEB">
            <h5>Pros:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Easy to implement</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Reads automatically when the field is focused if “Speak Hints” is on.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Cons:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Can be turned off (“Speak Hints”)</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Intended for interaction guidance, not business logic</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Not recommended as the only place for required information or errors</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h4>Method 3: <code>UIAccessibilityCustomContent</code></h4>
          </section>

          <section data-background="#EDEBEB">
            <p><code>UIAccessibilityCustomContent</code> allows you to <b>attach structured metadata (key–value)</b> to a control.</p>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Visible text label</span>
Text("Phone")
  .font(.headline)

<span class="codeComment">// Form field</span>
TextField("", text: $phone)
  .accessibilityLabel("Phone, required")
  <span class="codeHighlight">.accessibilityCustomContent(
    "Error", "Must include your area code"
  )</span></code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Key</span>

TextField("Phone", text: $phone)
  .accessibilityLabel("Phone, required")
  .accessibilityCustomContent(
    <span class="codeHighlight">"Error"</span>, "Must include your area code"
  )</code></pre>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Value</span>

TextField("", text: $phone)
  .accessibilityLabel("Phone, required")
  .accessibilityCustomContent(
    "Error", <span class="codeHighlight">"Must include your area code"</span>
  )</code></pre>
          </section>

          <section data-background="#EDEBEB">
            <h5>Pros:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>Structured key/value pairs</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Supports multiple types of information</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>More flexible than a single hint</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Cons:</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span>By default, this content is only available through the rotor</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Not all users know how to use the rotor</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Not guaranteed to be announced when the field receives focus</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p>You can also set <code>UIAccessibilityCustomContent</code> with <code>importance: .high</code>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>The <code>importance: .high</code> promotes this content <b>into the main VoiceOver announcement</b>, while preserving its key–value structure.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>This means that both the <b>key and value</b> are announced together.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>More importantly, this content is available <b>without needing the rotor</b>.</p>
          </section>

          <section data-background="#222">
<pre><code contenteditable="true"><span class="codeComment">// Visible text label</span>
Text("Phone")
  .font(.headline)

<span class="codeComment">// Form field</span>
TextField("", text: $phone)
  .accessibilityLabel("Phone, required")
  .accessibilityCustomContent(
    "Error", "Must include your area code"
    <span class="codeHighlight">importance: .high</span>
  )</code></pre>
</section>

          <section data-background="#EDEBEB">
            <p>There are some <b>possible exceptions</b> where high-importance content may not be included.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>Issues with using .high</h5>
            <ul class="icon-list font-sm">
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.high</code> is still ignored on some iOS 15–17 devices.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>When hints are off, some versions of iOS treat <code>.high</code> like a hint even though it is not one.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span>If the field already has a hint, custom content sometimes disappears entirely.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <p>There are more complex techniques developers can use to <b>build fully custom accessible components</b>, especially in UIKit.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>For now, we have focussed on SwiftUI’s <b>standard accessibility tools</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <p>Let&rsquo;s look at <b>a quick demo</b>.</p>
          </section>

          <section data-background="#EDEBEB">
            <h5>Which of these methods do you prefer?</h5>
            <ul class="icon-list">
              <li><span aria-hidden="true" class="icon icon-check"></span>Method 1: <code>accessibilityLabel</code></li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Method 2: <code>accessibilityHint</code></li>
              <li><span aria-hidden="true" class="icon icon-check"></span>Method 3: <code>UIAccessibilityCustomContent</code></li>
            </ul>
          </section>
        </section>



<!--  –––––––––––––––––––––––––
******  SECTION ******
––––––––––––––––––––––––––  -->



        <section id="slide-accessibility-modifier-list">
          <section data-background="#EDEBEB">
            <h3>SwiftUI accessibility modifier list</h3>
          </section>

          <section data-background="#EDEBEB">
            <h5>Naming</h5>
            <ul class="icon-list font-xs">
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityLabel</code>: Sets the element’s spoken name.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityValue</code>: Announces the current value.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityHint</code>: Adds extra guidance.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityFootnote</code>: Adds secondary explanatory text.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Visibility &amp; structure</h5>
            <ul class="icon-list font-xs">
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityHidden</code>: Hides the element from accessibility.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityElement(children:)</code>: Controls how child views appear (include them, combine them, or ignore them).</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityElement(_:)</code>: Marks a view as a single accessibility element.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityRespondsToUserInteraction</code>: Controls whether the element is focusable.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Traits (roles &amp; characteristics)</h5>
            <ul class="icon-list font-xs">
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityAddTraits</code>: Adds traits (button, selected, etc.).</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityRemoveTraits</code>: Removes traits (e.g. take away “button”).</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Ordering &amp; navigation</h5>
            <ul class="icon-list font-xs">
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilitySortPriority</code>: Changes the reading/focus order.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityTraversalAction</code>: Custom behaviour for next/previous focus.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityScrollActio</code>n — Custom behaviour when user scrolls via VoiceOver.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityZoomAction</code>: Custom behaviour when user performs zoom gestures.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Actions</h5>
            <ul class="icon-list font-xs">
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityAction</code>: Adds a custom action.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityAction(named:)</code>: Adds a labelled custom action.</li>
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityAdjustableAction</code>: Handles increment/decrement actions (like sliders).</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Rewrite semantics (use with caution)</h5>
            <ul class="icon-list font-xs">
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityRepresentation</code>: Replaces the view’s entire accessibility identity.</li>
            </ul>
          </section>

          <section data-background="#EDEBEB">
            <h5>Identifiers (testing only)</h5>
            <ul class="icon-list font-xs">
              <li><span aria-hidden="true" class="icon icon-check"></span><code>.accessibilityIdentifier</code>: Used only for UI tests; no effect on accessibility.</li>
            </ul>
          </section>
        </section>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/headjs/1.0.3/head.min.js"></script>
    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'none',
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealNotes ]
      });
    </script>

  </body>
</html>
